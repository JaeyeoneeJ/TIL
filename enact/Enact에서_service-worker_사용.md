> 아래 테스트 내용은 저의 github에 수록되어 있습니다. 테스트 앱의 확인이 필요한 경우, [enact-test](https://github.com/JaeyeoneeJ/enact-test)를 통해 프로젝트를 확인할 수 있습니다.

## 0. 개요
- enact는 자체적으로 내장 스크립트를 가지고 있어 CRA에서의 `react-script`와는 차이점을 가지고 있다.
- 따라서, CRA에서 자동으로 설정해주는 webpack 설정과는 다른 방식으로 구동이 된다.
- CRA의 경우, webpack 설정을 커스텀할 수 있는 `react-app-rewired`과 같은 라이브러리가 존재하지만 안타깝게도 enact는 이러한 라이브러리가 없다.
- 따라서 webpack 설정을 변경하려면 `enact eject` 명령어를 통해 webpack 및 스크립트 설정을 꺼내어 사용해야만 한다.
- 아래에 예제를 통해 `enact eject`를 통해 service-worker를 사용할 수 있도록 webpack 설정을 변경하는 방법을 알아보자.


## 1. enact project 생성
### enact CLI 설치
- enact 프로젝트를 생성하기 위해서는 enact가 전역으로 설치되어 있어야 한다.
```bash
npm install -g @enact/cli
```
- 설치가 완료되면 `enact -v`로 enact CLI 버전을 확인할 수 있다.

### 2) enact app 생성
- 먼저 해야할 일은 enact 프로젝트를 생성하는 것이다.
- webOS 기반 시스템(webOS TV 등)용 앱을 개발하는 경우, 템플릿을 사용하여 애플리케이션을 만들 수 있다.
```bash
enact template install @enact/template-webostv
enact create -t webostv [<directory>]
```

### 3) 필요한 라이브러리 설치
- 나의 경우, panel 단위 이동을 구현하기 위해 redux를 설치하였다.
- webpack과 관련한 라이브러리는 eject 후에 포함하도록 하자


## 2. `enact-eject`
- 간단한 세팅이 끝났다면 `enact-eject` 명령어를 실행하여 enact 내부 구조를 들여다볼 시간이다.
```
├── README.md
├── config
│   ├── babel.config.js
│   ├── corejs-proxy.js
│   ├── createEnvironmentHash.js
│   ├── custom-skin-template.ejs
│   ├── dotenv.js
│   ├── html-template.ejs
│   ├── jest
│   │   ├── babelTransform.js
│   │   ├── cssTransform.js
│   │   ├── fileTransform.js
│   │   ├── jest.config.js
│   │   └── setupTests.js
│   ├── paths.js
│   ├── polyfills.js
│   └── webpack.config.js
├── package-lock.json
├── package.json
├── package.old.json
├── resources
│   └── ilibmanifest.json
├── scripts
│   ├── clean.js
│   ├── info.js
│   ├── license.js
│   ├── lint.js
│   ├── pack.js
│   ├── serve.js
│   └── test.js
├── src
│   ├── App
│   │   ├── App.js
│   │   ├── App.module.less
│   │   ├── attachErrorHandler.js
│   │   └── package.json
│   ├── assets
│   │   └── volodymyr-m-QX_7m4Lh2qg-unsplash.jpg
│   ├── components
│   │   ├── README.md
│   │   ├── TButton
│   │   │   └── TButton.js
│   │   ├── TPanel
│   │   │   ├── TPanel.js
│   │   │   ├── TPanel.module.less
│   │   │   └── package.json
│   │   └── index.js
│   ├── features
│   │   └── panels
│   │       └── panelsSlice.js
│   ├── index.js
│   ├── service-worker.js
│   ├── serviceWorkerRegistration.js
│   ├── store
│   │   └── store.js
│   ├── utils
│   │   └── Config.js
│   └── views
│       ├── MainPanel.js
│       ├── MainView
│       │   └── MainView.js
│       ├── README.md
│       ├── Test1Panel.js
│       ├── Test2Panel.js
│       ├── Test3Panel.js
│       ├── Test4Panel.js
│       └── Test5Panel.js
└── webos-meta
    ├── appinfo.json
    ├── icon-large.png
    ├── icon-mini.png
    └── icon.png
```
- 위의 구조를 보면 config 폴더와 scripts 폴더가 추가로 생성된 것이 보일 것이다. 이를 통해 eject가 성공적으로 완료된 것을 알 수 있다.
- 예로 `package.json`을 보면
```json
  "scripts": {
    "serve": "node ./scripts/serve.js",
    "pack": "node ./scripts/pack.js",
    "pack-p": "node ./scripts/pack.js -p",
    "watch": "node ./scripts/pack.js --watch",
    "clean": "node ./scripts/clean.js",
    "lint": "node ./scripts/lint.js .",
    "license": "node ./scripts/license.js",
    "test": "node ./scripts/test.js",
    "test-watch": "node ./scripts/test.js --watch"
  },
```
- script가 위와 같이 변경되어 있을 것이다. 즉, scripts 폴더의 파일을 실행하는 것을 확인할 수 있다.

## 3. service-worker 연결
- 먼저 workbox 관련 플러그인을 설치한다.
```bash
npm install workbox-webpack-plugin workbox-core workbox-expiration workbox-precaching workbox-routing workbox-strategies
```

### 1) service-worker 파일 생성
- serviceWorker를 등록하기 위해서는 `/src` 경로에 service-worker.js 파일이 존재해야 한다.
- 우선 나의 경우에는 해당 파일의 형식을 CRA PWA template을 참조하였다.
- 즉, CRA에서 PWA-template으로 프로젝트를 생성할 때, 자동으로 생성되는 파일을 사용했다.
```js
//src/service-worker.js
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    } // If this is a URL that starts with /_, skip.

    if (url.pathname.startsWith('/_')) {
      return false;
    } // If this looks like a URL for a resource, because it contains // a file extension, skip.

    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    } // Return true to signal that we want to use the handler.

    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'), // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'images',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Any other custom service worker logic can go here.

```

```js
//src/serviceWorkerRegistration.js
// This optional code is used to register a service worker.
// register() is not called by default.

// This lets the app load faster on subsequent visits in production, and gives
// it offline capabilities. However, it also means that developers (and users)
// will only see deployed updates on subsequent visits to a page, after all the
// existing tabs open on the page have been closed, since previously cached
// resources are updated in the background.

// To learn more about the benefits of this model and instructions on how to
// opt-in, read https://cra.link/PWA

const isLocalhost = Boolean(
  window.location.hostname === 'localhost' ||
    // [::1] is the IPv6 localhost address.
    window.location.hostname === '[::1]' ||
    // 127.0.0.0/8 are considered localhost for IPv4.
    window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)
);

export function register(config) {
  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {
    // The URL constructor is available in all browsers that support SW.
    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);
    if (publicUrl.origin !== window.location.origin) {
      // Our service worker won't work if PUBLIC_URL is on a different origin
      // from what our page is served on. This might happen if a CDN is used to
      // serve assets; see https://github.com/facebook/create-react-app/issues/2374
      return;
    }

    window.addEventListener('load', () => {
      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;

      if (isLocalhost) {
        // This is running on localhost. Let's check if a service worker still exists or not.
        checkValidServiceWorker(swUrl, config);

        // Add some additional logging to localhost, pointing developers to the
        // service worker/PWA documentation.
        navigator.serviceWorker.ready.then(() => {
          console.log(
            'This web app is being served cache-first by a service ' +
              'worker. To learn more, visit https://cra.link/PWA'
          );
        });
      } else {
        // Is not localhost. Just register service worker
        registerValidSW(swUrl, config);
      }
    });
  }
}

function registerValidSW(swUrl, config) {
  navigator.serviceWorker
    .register(swUrl)
    .then((registration) => {
      registration.onupdatefound = () => {
        const installingWorker = registration.installing;
        if (installingWorker == null) {
          return;
        }
        installingWorker.onstatechange = () => {
          if (installingWorker.state === 'installed') {
            if (navigator.serviceWorker.controller) {
              // At this point, the updated precached content has been fetched,
              // but the previous service worker will still serve the older
              // content until all client tabs are closed.
              console.log(
                'New content is available and will be used when all ' +
                  'tabs for this page are closed. See https://cra.link/PWA.'
              );

              // Execute callback
              if (config && config.onUpdate) {
                config.onUpdate(registration);
              }
            } else {
              // At this point, everything has been precached.
              // It's the perfect time to display a
              // "Content is cached for offline use." message.
              console.log('Content is cached for offline use.');

              // Execute callback
              if (config && config.onSuccess) {
                config.onSuccess(registration);
              }
            }
          }
        };
      };
    })
    .catch((error) => {
      console.error('Error during service worker registration:', error);
    });
}

function checkValidServiceWorker(swUrl, config) {
  // Check if the service worker can be found. If it can't reload the page.
  fetch(swUrl, {
    headers: { 'Service-Worker': 'script' },
  })
    .then((response) => {
      // Ensure service worker exists, and that we really are getting a JS file.
      const contentType = response.headers.get('content-type');
      if (
        response.status === 404 ||
        (contentType != null && contentType.indexOf('javascript') === -1)
      ) {
        // No service worker found. Probably a different app. Reload the page.
        navigator.serviceWorker.ready.then((registration) => {
          registration.unregister().then(() => {
            window.location.reload();
          });
        });
      } else {
        // Service worker found. Proceed as normal.
        registerValidSW(swUrl, config);
      }
    })
    .catch(() => {
      console.log('No internet connection found. App is running in offline mode.');
    });
}

export function unregister() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.ready
      .then((registration) => {
        registration.unregister();
      })
      .catch((error) => {
        console.error(error.message);
      });
  }
}

```
- 위 두 파일을 src 폴더에 넣는다.

### 2) service-worker 등록
- 파일을 생성했다면 `index.js`에 service-worker를 등록해주어야 한다.
```js
//src/index.js
import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App";
import * as serviceWorkerRegistration from "./serviceWorkerRegistration";
import reportWebVitals from "./reportWebVitals";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want your app to work offline and load faster, you can change
// unregister() to register() below. Note this comes with some pitfalls.
// Learn more about service workers: https://cra.link/PWA
// serviceWorkerRegistration.unregister();
serviceWorkerRegistration.register();

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

```
- 위와 같이 `serviceWorkerRegistration.register();`를 추가해준다.
- 참고로 CRA PWA template으로 생성한 파일은 초기에 unregister로 되어 있을 것이다.

### 3) webpack.config.js 파일 수정
- serviceWorker를 잘 읽어오도록 `paths.js`을 만들어줬다.
```js
//config/paths.js
"use strict";

const path = require("path");
const fs = require("fs");
const getPublicUrlOrPath = require("react-dev-utils/getPublicUrlOrPath");

// Make sure any symlinks in the project folder are resolved:
// https://github.com/facebook/create-react-app/issues/637
const appDirectory = fs.realpathSync(process.cwd());
const resolveApp = (relativePath) => path.resolve(appDirectory, relativePath);

// We use `PUBLIC_URL` environment variable or "homepage" field to infer
// "public path" at which the app is served.
// webpack needs to know it to put the right <script> hrefs into HTML even in
// single-page apps that may serve index.html for nested URLs like /todos/42.
// We can't use a relative path in HTML because we don't want to load something
// like /todos/42/static/js/bundle.7289d.js. We have to know the root.
const publicUrlOrPath = getPublicUrlOrPath(
  process.env.NODE_ENV === "development",
  require(resolveApp("package.json")).homepage,
  process.env.PUBLIC_URL
);

const buildPath = process.env.BUILD_PATH || "build";

const moduleFileExtensions = [
  "web.mjs",
  "mjs",
  "web.js",
  "js",
  "web.ts",
  "ts",
  "web.tsx",
  "tsx",
  "json",
  "web.jsx",
  "jsx",
];

// Resolve file paths in the same order as webpack
const resolveModule = (resolveFn, filePath) => {
  const extension = moduleFileExtensions.find((extension) =>
    fs.existsSync(resolveFn(`${filePath}.${extension}`))
  );

  if (extension) {
    return resolveFn(`${filePath}.${extension}`);
  }

  return resolveFn(`${filePath}.js`);
};

// config after eject: we're in ./config/
module.exports = {
  swSrc: resolveModule(resolveApp, "src/service-worker"),
};

module.exports.moduleFileExtensions = moduleFileExtensions;

```

- `/config/webpack.config.js` 파일을 수정해보자
```js
//config/webpack.config.js
...
const WorkboxWebpackPlugin = require("workbox-webpack-plugin");
const { swSrc } = require("./paths");

...
module.exports = function (...) {
  return {
    plugins: [
      isEnvProduction &&
        fs.existsSync(swSrc) &&
        new WorkboxWebpackPlugin.InjectManifest({
          swSrc,
          dontCacheBustURLsMatching: /\.[0-9a-f]{8}\./,
          exclude: [
            /\.map$/,
            /asset-manifest\.json$/,
            /LICENSE/,
            /node_modules\/ilib\//,
          ],
          // Bump up the default maximum size (2mb) that's precached,
          // to make lazy-loading failure scenarios less likely.
          // See https://github.com/cra-template/pwa/issues/13#issuecomment-722667270
          maximumFileSizeToCacheInBytes: 5 * 1024 * 1024,
        }),
      ...
	
    ]
  }
}
```
- 필요한 라이브러리를 import 하고 workbox 플러그인을 통해 설정한다.
- 여기에서 exclude는 제외할 파일로, 나의 경우 `ilib` 라이브러리의 json 파일이 너무 많아 프리캐시 시 오래 걸리는 문제가 발생하여 해당 경로를 제외했다.
- cache 파일의 크기를 조절하고 싶다면 `maximumFileSizeToCacheInBytes`의 숫자를 조정하면 된다.



<hr>
## ref.
- https://enactjs.com/docs/tutorials/setup/